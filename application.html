<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <title>RACE</title>

        <link href="./race-html.css" rel="stylesheet"/>
    </head>

    <body>
        <div class="navbar">
            <div class=""banner>
                <a href="./index.html" ><img class="logo" src="./images/odin128.png"></a>
                <p class="doctitle">Documentation</p>
            </div>
            <br/>
            <div class="toc">
                <p class="title">Project Links</p>
                <ul>
                    <li><span class="toc level2"><a href="https://github.com/NASARace/race-odin.git">Repository</a></span></li>
                    <li><span class="toc level2"><a href="http://nasarace.github.io/race-odin">Website</a></span></li>
                </ul>
            </div>
            <div class="toc pagetoc">
                <p class="title">Page</p>
                <ul class="nav-list">
                  <li class="level1 active"><a href="#">Anatomy of an ODIN-fire application</a></li>
                  <li class="level2"><a href="#_1-data-import">1. Data import</a></li>
                  <li class="level2"><a href="#_2-internal-data-model">2. Internal Data Model</a></li>
                  <li class="level2"><a href="#_3-data-processing">3. Data Processing</a></li>
                </ul>
            </div>
            <div class="toc globaltoc">
                <p class="title">Site</p>
                <ul class="nav-list">
                  <li class="level1 nav-header">RACE-ODIN Manual</li>
                  <li class="level2"><a href="index.html">About ODIN-fire</a></li>
                  <li class="level2"><a href="motivation.html">Motivation for RACE-ODIN</a></li>
                  <li class="level2"><a href="vision.html">Vision behind RACE-ODIN</a></li>
                  <li class="level2"><a href="opensource.html">Why is ODIN-fire Open Sourced</a></li>
                  <li class="level2"><a href="live-demo.html">Building and Running Live Data Demo</a></li>
                  <li class="level2"><a href="archive-demo.html">Building and Running Archive Replay Demo</a></li>
                  <li class="level2 active"><a href="#">Anatomy of an ODIN-fire application</a></li>
                  <li class="level2"><a href="presentations.html">Presentations</a></li>
                  <li class="level2"><a href="data-sources.html">Wildland Fire Data Sources</a></li>
                  <li class="level2"><a href="private-configuration.html">Private Configuration Vault</a></li>
                  <li class="level2"><a href="building-race.html">Obtain and Build RACE</a></li>
                  <li class="level2"><a href="common-root.html">Create Common Root Dir for RACE/ODIN</a></li>
                  <li class="level2"><a href="cesium-access-token.html">Cesium Access Token</a></li>
                  <li class="level2"><a href="building-race-odin.html">Obtain and Build RACE-ODIN</a></li>
                  <li class="level2"><a href="running-odin.html">Running RACE-ODIN Applications</a></li>
                  <li class="level2"><a href="prerequisites.html">Check Prerequisites for RACE-ODIN</a></li>
                </ul>
            </div>
        </div>

        <div class="main">
            <h1 id="anatomy-of-an-odin-fire-application" class="title">Anatomy of an ODIN-fire application</h1>
            <p>The demo application included in this repository shows the typical components that are required to integrate
            a new external data source - in this case <a href="https://delphiretech.com/sentinel">Delphire&#39;s Sentinel powerline fre monitoring system</a>.</p>
            <p>What we import here is raw data. If an external service provides data in a generic display or
            domain-aware format (such as KML or GeoJSON) we do not have to program anything but can use existing RACE/ODIN
            components in order to incorporate such layers in our visualization. However, using generic display formats can
            make it considerably harder to add specific visualization or non-visualization related functions such as monitoring.</p>
            <p>The three basic functions for raw data integration are (1) data import, (2) internal data model and (3) data processing.
            Each of these functions is implemented as a RACE<em>actor</em> that can make use of the existing RACE libraries. The sources
            can be found in the <code>src/main/scala/gov/nasa/race/odin/sentinel/</code> directory.</p>
            <img class="center scale75" src="images/sentinel-app.svg">
            
            <h3 id="_1-data-import" class="section"><a class="anchor-link left" href="#_1-data-import"><i class="icofont-laika">&#xef71;</i></a>1. Data import</h3>
            <p>This is the component that obtains data from the external (edge) server, either through http, a higher level
            protocol such as Java Messaging Service (JMS), or by direct socket communication. Please refer to 
            <a href="http://nasarace.github.io/race/design/connectivity.html">RACE import</a> documentation for general design and supported 
            protocols. In many cases all that is required in order to use  existing RACE components is to provide a <code>reader</code> that 
            de-serializes the data received from the external server into update events.</p>
            <p>A standout feature of RACE is that it supports to archive what we receive, and then to later-on replay such archives
            without requiring to access the external servers that data came from. This makes use of the 
            <a href="http://nasarace.github.io/race/design/archive-replay.html">RACE Archive and Replay</a> infrastructure. Replay provides 
            control over start-time and time-scale. The important aspect here is that the only application change that is required 
            is to swap the live import actor for a respective replay actor - the rest of the system stays the same.</p>
            <p>In our example we replay an archive of simulated Sentinel devices (<code>SentinelReplayActor.scala</code>).</p>
            
            <h3 id="_2-internal-data-model" class="section"><a class="anchor-link left" href="#_2-internal-data-model"><i class="icofont-laika">&#xef71;</i></a>2. Internal Data Model</h3>
            <p>This actor reads the  update events we receive from the import actor and accumulates them into an internal
            data model representing the states of known Sentinel devices. Upon startup, the actor tries to retrieve the
            last known state of these devices from local storage. During operation and upon termination this local
            storage is updated so that connectivity loss does not lead to losing the last known state. This actor
            typically first updates the data model and then emits a snapshot of the complete state, followed by the update
            events that lead to the new state snapshot. This allows clients such as monitor actors to efficiently react
            to specific state changes.</p>
            <p>The sources implementing our example data model are <code>Sentinel.scala</code>, <code>SentinelSensorReading.scala</code> and
            <code>SentinelUpdateActor.scala</code>. </p>
            
            <h3 id="_3-data-processing" class="section"><a class="anchor-link left" href="#_3-data-processing"><i class="icofont-laika">&#xef71;</i></a>3. Data Processing</h3>
            <p>This represents what to do with the accumulated data and respective changes. In our example we provide
            the Sentinel data as a micro-service that can be shown as a layer on top of a virtual globe in a browser.
            While this involves a lot of functionality the vast majority resides within the 
            <a href="http://nasarace.github.io/race/design/http-server.html">RACE HttpServer infrastructure</a>. Here we just have to implement 
            the <code>RaceRouteInfo</code> that deals with the Sentinel specifics, namely </p>
            <ul>
              <li>providing related document fragments (user interface components)</li>
            </ul>
            <ul>
              <li>serving related assets (such as symbols and browser script modules)</li>
            </ul>
            <ul>
              <li>pushing new Sentinel data through websockets to the connected clients</li>
            </ul>
            <p>In our example this can be found in <code>SentinelRoute.scala</code>.</p>
        </div>

    </body>
</html>
